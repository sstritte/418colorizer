<!doctype html>
<html lang="en"
<head>
    <title>Parallel High-Resolution Fluid Simulation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="assets/css/main.css" />
</head>

<body>

    <!-- Header -->
    <header id="header" class="alt">
        <a href="#menu">Menu</a>
    </header>

    <!-- Nav -->
    <nav id="menu">
        <ul class="links">
            <li><a href="index.html">Home</a></li>
            <li><a href="proposal.html">Proposal</a></li>
            <li><a href="checkpoint.html">Checkpoint</a></li>
        </ul>
    </nav>

    <!-- Banner -->
    <section id="banner">
        <div class="inner">
            <header>
                <h1>Parallel High-Resolution Fluid Simulation</h1>
                <p> 15-418 Final Project // Jennifer Chou (jtchou), Sienna Stritter (sstritte) </p>
            </header>
            <a href="https://github.com/sstritte/fluid-sim/" class="button big scrolly" target="_blank">View on Github</a>
        </div>
    </section>


    <!-- Main -->
    <div id="main">

        <!-- Section -->
        <section class="wrapper style1">
          <div class="inner">





            <h3>Summary</h3>
            <p>We implemented a fluid simulation on a CPU with OpenMP and on a GPU with CUDA from scratch, and compared the performance of the two implementations. The fluid responds to mouse interactions, and renders a display using OpenGL.</p>

            <h3>Demo</h3>
            <p align="center">
                <video controls="controls" width="500" height="500" name="Demo" src="fluid-sim-demo.mov" poster="images/demo_screenshot.png"></video>
            </p>

            <h3>Background</h3>
            <p>
                The simulation of fluids is computationally very expensive, and could benefit greatly from paralellization since computations are being done for each of the pixels.
            </p>

            <p>
                In a grid-based simulation like ours, the fluid is represented by dividing up the space a fluid might occupy into individual cells (in our case, pixels), and storing certain quantities of the fluid in each cell, like velocity, pressure, and color. These different quantities represent the fluid at each cell at a certain point in time, and are represented in separate arrays. 
            </p>
            <p align="center">
                <img src="images/gridbased.jpg" alt="Grid based simulation" style="max-width:100%;" > <br>
                A grid-based representation with a single quantity (velocity, for example)
            </p>
            <p>
                A fundamental operation in grid-based fluid dynamics is advection, which is moving quantities across the grid for the next time step based on the current velocity of each cell. Simplified, forward advection is calculating where the fluid in your cell will be at the next time step, and giving your current quantity that you're advecting (velocity or color) to the cell where the fluid will be. Backwards advection is trickier to understand, but it's essentially the same idea except you trace your velocity backwards and pull that value into your cell. Additionally, there are other operations to create realistic fluid motion, accounting for vorticity (rotation), divergence, pressure, and color.
            </p>
            <p>
                We can use parallelization within each of these computations to perform the operations on each cell in parallel. However, due to the nature of fluid motion, the state of a cell is affected by its neighboring cells, so these operations require accessing quantities from cells other than your cell. This introduces a level of complexity, since operations have to be fully completed for the entire grid in order to move onto the next operation. This is because the computation for a given cell relies on the result of previous computations for both itself and its neighboring cells.
            </p>
            <p>
                <div class="flex flex-3">
                    <div class="col align-center">
                        <img src="images/dependencies.png" alt="Operation dependencies" style="max-height:400px; max-width:100%;" >
                        <br>
                        Dependency graph for our implementation
                    </div>
                    <div class="col align-center">
                        <img src="images/advection.png" alt="Advection" style="height:200px; max-width:100%;" >
                        <br>
                        In advection, the computation for a cell loads/stores quantities from other cells 
                    </div>
                    <div class="col align-center">
                        <img src="images/neighbors.png" alt="Reading from neighbor cells" style="height:200px; max-width:100%;" >
                        <br>
                        In the operations from applyVorticity() to pressureGradient(), quantities from neighboring cells are used
                    </div>

                </div>
            </p>
            <p>
                At the end of each time step, the appropriate colors are given to OpenGL to render onto the screen. The faster the computation is, the faster each frame is able to be rendered, which creates a more seamless animation.
            </p>

            <h3>Approach</h3>
            <p>

                We used CUDA to map the computation onto the GPU. Specifically, we copied all the arrays into device memory and translated each of the operations into kernels, which we called for each grid cell using 16x16 thread blocks. Because of the dependencies, we had to separate kernel instances for each operation in order to synchronize before moving on to the next operation. 
            </p>
            <p>
                One area that we put special thought into was processing the mouse press events, since you need to go through all the mouse segments that were pressed since the last screen render for each pixel. We considered the tradeoffs between launching a kernel for each pixel and having a loop within the kernel to loop through the mouse segments, or flattening it and having a thread for each pixel-segment pair. We figured that since the number of segments would likely be small compared to the number of pixels in the image (usually less than 50), it would be better to have a thread for each pixel with the loop. This would have less kernel launch overhead and less communication between threads in a thread block, since the purpose of looping was to find the pixel's minimum length to any of the mouse segments. In the flattened version, the threads in a thread block would have needed to communicate with each other to determine what the minimum length was.
            </p>
            <p>
                Simply translating the implementation to CUDA kernels improved the computation time drastically. Next, we decided to take advantage of shared memory in a thread block to achieve further speedup. For both advection and the operations that access the pixel's immediate neighbors, it is highly likely that the other cells being read from or written to will be in the same thread block. Only pixels along the perimeter or pixels with large velocities will have to access global device memory for cells quantities outside of the thread block.
            </p>
            <p>
                <div class="flex flex-2">
                    <div class="col align-center">
                        <img src="images/advection_blocks.png" alt="Advection" style="height:200px;" >
                        <br>
                        Advection within and outside a thread block
                    </div>
                    <div class="col align-center">
                        <img src="images/neighbors_blocks.png" alt="Reading from neighbor cells" style="height:200px; max-width:100%;" >
                        <br>
                        Looking at a pixel's direct neighbors will mostly use shared memory, except on the perimeters 
                    </div>


                </div>
            </p>


        </p>

        <h3>Results</h3>

        <h3>References</h3>
        <p>
            We mainly referenced <a href="http://cowboyprogramming.com/2008/04/01/practical-fluid-mechanics/" style="color: blue;">Practical Fluid Mechanics</a> and <a href="https://github.com/haxiomic/GPU-Fluid-Experiments" style="color: blue;">haxiomic's GPU-Fluid-Experiments</a> to understand the physics of fluid motion.
        </p>

        <h3>List of Work Done by Each Student</h3>

        <p> Equal work was performed by both project members. </p>

    </div>
</section>
</div>


<!-- Scripts -->
<script src="assets/js/jquery.min.js"></script>
<script src="assets/js/jquery.scrolly.min.js"></script>
<script src="assets/js/jquery.scrollex.min.js"></script>
<script src="assets/js/skel.min.js"></script>
<script src="assets/js/util.js"></script>
<script src="assets/js/main.js"></script>

</body>
</html>









